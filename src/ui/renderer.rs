use crate::{drive::{DriveObject, Notebook, Prompt, Workflow}, app::{state::{App, AppMode, PaletteItem, PromptMode, InputPosition, CursorShape}, pane::{AgentState}}, agent::client::AgentResponse, pty::vte_handler::VteState, config::{TextConfig, theme::Theme}, };use cosmic_text::{Attrs, Buffer, Color, Editor, FontSystem, Metrics, Shaping, SwashCache, Weight, Style as FontStyle, AttrsList, Edit};use winit::window::Window;use std::time::Duration;use similar::ChangeTag;use crate::vim::{VimMode};use vte::ansi::Color as VteColor;use crate::app::state::Grid;use crate::pty::vte_handler::GridCoords;fn hex_to_color(hex: &str) -> Color {    let hex = hex.trim_start_matches('#');    let (r, g, b) = match hex.len() {        6 => (            u8::from_str_radix(&hex[0..2], 16).unwrap_or(255),            u8::from_str_radix(&hex[2..4], 16).unwrap_or(255),            u8::from_str_radix(&hex[4..6], 16).unwrap_or(255),        ),        _ => (255, 255, 255),    };    Color::rgb(r, g, b)}fn to_cosmic_color(c: VteColor, theme: &Theme) -> Color {    match c {        VteColor::Named(c) => match c {            vte::ansi::NamedColor::Black => hex_to_color(&theme.colors.normal.black),            vte::ansi::NamedColor::Red => hex_to_color(&theme.colors.normal.red),            vte::ansi::NamedColor::Green => hex_to_color(&theme.colors.normal.green),            vte::ansi::NamedColor::Yellow => hex_to_color(&theme.colors.normal.yellow),            vte::ansi::NamedColor::Blue => hex_to_color(&theme.colors.normal.blue),            vte::ansi::NamedColor::Magenta => hex_to_color(&theme.colors.normal.magenta),            vte::ansi::NamedColor::Cyan => hex_to_color(&theme.colors.normal.cyan),            vte::ansi::NamedColor::White => hex_to_color(&theme.colors.normal.white),            vte::ansi::NamedColor::BrightBlack => hex_to_color(&theme.colors.bright.black),            vte::ansi::NamedColor::BrightRed => hex_to_color(&theme.colors.bright.red),            vte::ansi::NamedColor::BrightGreen => hex_to_color(&theme.colors.bright.green),            vte::ansi::NamedColor::BrightYellow => hex_to_color(&theme.colors.bright.yellow),            vte::ansi::NamedColor::BrightBlue => hex_to_color(&theme.colors.bright.blue),            vte::ansi::NamedColor::BrightMagenta => hex_to_color(&theme.colors.bright.magenta),            vte::ansi::NamedColor::BrightCyan => hex_to_color(&theme.colors.bright.cyan),            vte::ansi::NamedColor::BrightWhite => hex_to_color(&theme.colors.bright.white),            _ => hex_to_color(&theme.colors.primary.foreground),        },        VteColor::Spec(rgb) => Color::rgb(rgb.r, rgb.g, rgb.b),        VteColor::Indexed(idx) => {            let r = (idx & 0xE0) >> 5;            let g = (idx & 0x1C) >> 2;            let b = idx & 0x03;            Color::rgb(r * 36, g * 36, b * 72)        }        VteColor::Default => hex_to_color(&theme.colors.primary.foreground),    }}pub struct Renderer<'a> {    surface: wgpu::Surface<'static>,    device: wgpu::Device,    queue: wgpu::Queue,    config: wgpu::SurfaceConfiguration,    font_system: FontSystem,    swash_cache: SwashCache,    buffer: Buffer,    editor: Editor<'a>,    pub char_width: f32,    pub char_height: f32,}impl<'a> Renderer<'a> {    pub async fn new(window: &Window, font_data: Vec<u8>, text_config: &TextConfig) -> Self {        let size = window.inner_size();        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor::default());        let surface = instance.create_surface(window).unwrap();        let adapter = instance.request_adapter(&wgpu::RequestAdapterOptions::default()).await.unwrap();        let (device, queue) = adapter.request_device(&wgpu::DeviceDescriptor::default(), None).await.unwrap();        let surface_caps = surface.get_capabilities(&adapter);        let surface_format = surface_caps.formats.iter().copied().find(|f| f.is_srgb()).unwrap_or(surface_caps.formats[0]);        let composite_alpha_mode = surface_caps.alpha_modes            .iter()            .copied()            .find(|&m| m == wgpu::CompositeAlphaMode::Auto || m == wgpu::CompositeAlphaMode::PreMultiplied)            .unwrap_or(surface_caps.alpha_modes[0]);        let config = wgpu::SurfaceConfiguration {            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,            format: surface_format,            width: size.width,            height: size.height,            present_mode: wgpu::PresentMode::AutoVsync,            alpha_mode: composite_alpha_mode,            view_formats: vec![],            desired_maximum_frame_latency: 2,        };        surface.configure(&device, &config);        let mut font_system = FontSystem::new();        let swash_cache = SwashCache::new();        font_system.db_mut().load_font_data(font_data);        let attrs = Attrs::new();        let metrics = Metrics::new(text_config.font_size, text_config.font_size * text_config.line_height);        let shaping = if text_config.use_ligatures { Shaping::Advanced } else { Shaping::Basic };        let mut buffer = Buffer::new(&mut font_system, metrics);        buffer.set_size(&mut font_system, Some(size.width as f32), Some(size.height as f32));        // buffer.set_shaping(&mut font_system, shaping); // Removed as per cosmic-text 0.11 API        let editor = Editor::new(buffer);        let mut buffer_mono = Buffer::new(&mut font_system, metrics);        buffer_mono.set_text(&mut font_system, "M", attrs, Shaping::Advanced);        let char_width = buffer_mono.layout_runs().next().map_or(text_config.font_size, |run| run.glyphs.first().map_or(0.0, |g| g.w));        Self {            surface, device, queue, config, font_system, swash_cache, buffer: editor.buffer().clone(), editor,            char_width, char_height: text_config.font_size * text_config.line_height,        }    }    pub fn sync_with_vte(&mut self, vte_state: &VteState, theme: &Theme) {        let grid = vte_state.get_grid();        let mut text = String::new();        let mut attrs_list = AttrsList::new(Attrs::new());        for row in grid.rows_iter() {            for cell in row {                text.push(cell.c);                let mut attrs = Attrs::new().color(to_cosmic_color(cell.fg, theme));                if cell.flags.contains(vte::ansi::Flags::BOLD) {                    attrs = attrs.weight(Weight::BOLD);                }                if cell.flags.contains(vte::ansi::Flags::ITALIC) {                    attrs = attrs.style(FontStyle::Italic);                }                let start = text.len() - 1;                attrs_list.add_span(start..text.len(), attrs);            }            text.push('\n');        }        self.editor.buffer_mut().set_text(&mut self.font_system, &text, attrs_list, Shaping::Advanced);        self.editor.shape_as_needed(&mut self.font_system, true);    }    pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) -> (u16, u16) {        if new_size.width > 0 && new_size.height > 0 {            self.config.width = new_size.width;            self.config.height = new_size.height;            self.surface.configure(&self.device, &self.config);            self.editor.buffer_mut().set_size(&mut self.font_system, Some(new_size.width as f32), Some(new_size.height as f32));            self.editor.shape_as_needed(&mut self.font_system, true);        }        let cols = (new_size.width as f32 / self.char_width).floor() as u16;        let rows = (new_size.height as f32 / self.char_height).floor() as u16;        (cols, rows)    }    pub fn render(&mut self, app: &mut App, time_since_start: Duration) -> Result<(), wgpu::SurfaceError> {        let output = self.surface.get_current_texture()?;        let view = output.texture.create_view(&wgpu::TextureViewDescriptor::default());        let mut encoder = self.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });        {            let bg = hex_to_color(&app.theme.colors.primary.background);            let alpha = app.config.appearance.opacity;            let clear_color = if alpha < 1.0 {                wgpu::Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 }            } else {                wgpu::Color {                    r: bg.r() as f64 / 255.0,                    g: bg.g() as f64 / 255.0,                    b: bg.b() as f64 / 255.0,                    a: 1.0,                }            };            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {                label: None,                color_attachments: &[Some(wgpu::RenderPassColorAttachment {                    view: &view,                    resolve_target: None,                    ops: wgpu::Operations {                        load: wgpu::LoadOp::Clear(clear_color),                        store: wgpu::StoreOp::Store,                    },                })],                ..Default::default()            });            let (win_width, win_height) = (self.config.width as f32, self.config.height as f32);            let num_panes = app.panes.len();            let pane_width = win_width / num_panes as f32;            for (pane_idx, pane) in app.panes.iter().enumerate() {                let pane_x = pane_idx as f32 * pane_width;                let mut y_offset = 0.0;                // --- 1. RENDER HISTORICAL BLOCKS ---                for (block_idx, block) in pane.history.iter().enumerate() {                    // Render prompt and command                    let cmd_text = format!("> {}", block.command);                    let mut cmd_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    cmd_buffer.set_size(&mut self.font_system, Some(pane_width), Some(self.char_height * 1.2));                    cmd_buffer.set_text(&mut self.font_system, &cmd_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(cmd_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    y_offset += self.char_height * 1.2;                    // Render output                    let mut output_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    output_buffer.set_size(&mut self.font_system, Some(pane_width), Some(self.char_height * 4.0));                    output_buffer.set_text(&mut self.font_system, &block.output, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(output_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    y_offset += self.editor.buffer().total_height().max(self.char_height * 2.0);                    // Render "..." menu icon                    let mut menu_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    menu_buffer.set_size(&mut self.font_system, Some(30.0), Some(self.char_height * 1.2));                    menu_buffer.set_text(&mut self.font_system, "â‹¯", Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(menu_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                }                // --- 2. RENDER THE LIVE VTE GRID ---                let vte_state = pane.current_vte.lock().unwrap();                self.sync_with_vte(&vte_state, &app.theme);                self.editor.buffer_mut().set_size(&mut self.font_system, Some(pane_width), Some(win_height - y_offset));                self.editor.shape_as_needed(&mut self.font_system, true);                self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                // --- 3. RENDER BLOCK CONTEXT MENU (if active) ---                if let AppMode::BlockMenu(state) = &app.mode {                    if state.pane_idx == pane_idx {                        let menu_items = ["Copy Command", "Copy Output", "Re-input Command"];                        let menu_width = 220.0;                        let menu_height = self.char_height * menu_items.len() as f32 * 1.2 + 20.0;                        let menu_x = pane_x + pane_width - menu_width - 10.0;                        let menu_y = 40.0 + (state.block_idx as f32) * self.char_height * 2.0;                        let mut menu_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                        menu_buffer.set_size(&mut self.font_system, Some(menu_width), Some(menu_height));                        let mut menu_text = String::new();                        for (i, item) in menu_items.iter().enumerate() {                            if i == state.selected_action_idx {                                menu_text.push_str(&format!("> {}\n", item));                            } else {                                menu_text.push_str(&format!("  {}\n", item));                            }                        }        menu_buffer.set_text(&mut self.font_system, &menu_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                        self.editor.set_buffer(menu_buffer);                        self.editor.shape_as_needed(&mut self.font_system, true);                        self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                        self.editor.set_buffer(self.buffer.clone());                    }                }            }            // Restore the main buffer for overlays/cursor            self.editor.set_buffer(self.buffer.clone());            // --- PROMPT RENDERING LOGIC ---            let mut terminal_y_offset = 0.0;            if app.config.appearance.prompt_mode == PromptMode::Warpish {                let mut prompt_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                prompt_buffer.set_size(&mut self.font_system, Some(self.config.width as f32), Some(self.char_height * 2.0));                // --- Build the prompt string from chips (with placeholder data) ---                let mut prompt_text = String::new();                for chip in &app.config.appearance.warpish_prompt.chips {                    let chip_text = match chip.as_str() {                        "cwd" => " /users/dev/warpish_terminal ", // Placeholder                        "git" => " on main [!] ", // Placeholder                        "time" => " 12:34 PM ", // Placeholder                        _ => " unknown_chip "                    };                    prompt_text.push_str(chip_text);                }                prompt_text.push('>');                prompt_buffer.set_text(&mut self.font_system, &prompt_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                self.editor.set_buffer(prompt_buffer);                self.editor.shape_as_needed(&mut self.font_system, true);                self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                if !app.config.appearance.warpish_prompt.same_line {                    terminal_y_offset = self.char_height;                }            }            // --- Draw main terminal text, respecting the offset ---            self.editor.set_buffer(self.buffer.clone());            self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);            // --- RENDER CURSOR (NEW) ---            let grid = app.panes[app.active_pane_idx].current_vte.lock().unwrap().get_grid();            if !grid.cursor_hidden() {                let is_blinking_on = if !app.config.appearance.cursor.blink {                    true                } else {                    (time_since_start.as_millis() / 500) % 2 == 0                };                if is_blinking_on {                    self.render_cursor(app, &grid.cursor_position(), &mut render_pass);                }            }            // --- RENDER AGENT MODE UI ---            if let AppMode::Agent(state) = &app.mode {                let mut agent_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                agent_buffer.set_size(&mut self.font_system, Some(self.config.width as f32), Some(self.config.height as f32));                let mut text = String::new();                for (query, response) in &state.conversation {                    text.push_str(&format!("> {}\n", query));                    match response {                        AgentResponse::SuggestCommand { explanation, command } => {                            text.push_str(&format!("ðŸ¤– {}\n", explanation));                            text.push_str(&format!("[Suggested Command: {}\n\n", command));                        }                        AgentResponse::RequestToRunCommand { explanation, command_to_run } => {                            text.push_str(&format!("ðŸ¤– {}\n", explanation));                            text.push_str(&format!("[Press ENTER to run `{}` or ESC to cancel]\n\n", command_to_run));                        }                        AgentResponse::Clarification(c) => text.push_str(&format!("ðŸ¤– {}\n\n", c)),                    }                }                agent_buffer.set_text(&mut self.font_system, &text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                self.editor.set_buffer(agent_buffer);                self.editor.shape_as_needed(&mut self.font_system, true);                self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                // --- Render the special Agent Input Bar at the bottom ---                let mut input_text = format!("âœ¨ {}", state.current_input);                self.render_input_bar(app, (0.0, self.config.height as f32 - self.char_height * 1.5), &mut render_pass);            } else {                // --- RENDER NORMAL/PINNED MODES ---                // --- RENDER OVERLAYS (Settings, Palette, etc.) ---                if let AppMode::Settings(state) = &app.mode {                    let prompt_mode_text = format!("\n\nPrompt Mode: {:?} (Press Enter to Toggle)", app.config.appearance.prompt_mode);                    let mut ui_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    ui_buffer.set_size(&mut self.font_system, Some(self.config.width as f32 - 50.0), Some(self.config.height as f32 - 50.0));                    let mut text = prompt_mode_text.clone();                    for (i, item) in state.filtered_list.iter().take(10).enumerate() {                        let (name, desc, kind) = match item {                            PaletteItem::Workflow(w) => (w.name.as_str(), w.description.as_str(), "Workflow"),                            PaletteItem::Notebook(n) => (n.name.as_str(), "", "Notebook"),                            PaletteItem::Action { name, description, .. } => (name.as_str(), description.as_str(), "Action"),                        };                        let line = if i == state.selected_idx {                            format!("> [{}] {} - {}\n", kind, name, desc)                        } else {                            format!("  [{}] {} - {}\n", kind, name, desc)                        };                        text.push_str(&line);                    }                    ui_buffer.set_text(&mut self.font_system, &text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(ui_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                } else if let AppMode::CommandPalette(state) = &app.mode {                    self.render_command_palette(app, state, &mut render_pass);                } else if let AppMode::HistorySearch(state) = &app.mode {                    self.render_history_search(app, state, &mut render_pass);                } else if let AppMode::Drive(state) = &app.mode {                    let (width, height) = (self.config.width as f32, self.config.height as f32);                    let padding = 20.0;                    let pane_split_x = width * 0.4;                    // --- Draw background overlay ---                    let mut bg_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    bg_buffer.set_size(&mut self.font_system, Some(width), Some(height));                    bg_buffer.set_text(&mut self.font_system, "â–ˆ", Attrs::new().color(Color::rgba(20, 20, 20, 230)), Shaping::Advanced);                    self.editor.set_buffer(bg_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // --- Draw Left Pane (File Tree) ---                    let mut left_pane_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    left_pane_buffer.set_size(&mut self.font_system, Some(pane_split_x - padding * 2.0), Some(height - padding * 2.0));                    let mut tree_text = String::new();                    for (i, (name, depth)) in state.flat_items.iter().enumerate() {                        let indent = "  ".repeat(*depth);                        let line = if i == state.selected_idx {                            format!("> {}{}\n", indent, name)                        } else {                            format!("  {}{}\n", indent, name)                        };                        tree_text.push_str(&line);                    }                    left_pane_buffer.set_text(&mut self.font_system, &tree_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    left_pane_buffer.set_wrap(&mut self.font_system, cosmic_text::Wrap::Word);                    self.editor.set_buffer(left_pane_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // --- Draw Right Pane (Content Preview) ---                    let mut right_pane_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    right_pane_buffer.set_size(&mut self.font_system, Some(width - pane_split_x - padding), Some(height - padding * 2.0));                    // Find the actual object corresponding to the selected index                    let mut current_idx = 0;                    let mut selected_object: Option<&DriveObject> = None;                    let mut idx = 1; // skip workspace titles                    for obj in app.drive_manager.personal_ws.objects.iter() {                        if idx == state.selected_idx {                            selected_object = Some(obj);                            break;                        }                        idx += 1;                    }                    if selected_object.is_none() {                        for ws in &app.drive_manager.team_workspaces {                            idx += 1; // skip team workspace title                            for obj in ws.objects.iter() {                                if idx == state.selected_idx {                                    selected_object = Some(obj);                                    break;                                }                                idx += 1;                            }                            if selected_object.is_some() { break; }                        }                    }                    let mut preview_text = "Select an item to preview".to_string();                    if let Some(obj) = selected_object {                        preview_text = match obj {                            DriveObject::Workflow(w, m) => format!("Name: {}\n\nDescription: {}\n\nCommand:\n{}", w.name, w.description, w.command),                            DriveObject::Notebook(n, m) => format!("Name: {}\n\n---\n\n{}", n.name, n.content),                            DriveObject::Prompt(p, m) => format!("Prompt: {}\n\n{}", p.name, p.content),                            DriveObject::EnvVars(e, m) => format!("Env: {}\n\n{:?}", e.name, e.vars),                        };                    }                    right_pane_buffer.set_text(&mut self.font_system, &preview_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    right_pane_buffer.set_wrap(&mut self.font_system, cosmic_text::Wrap::Word);                    self.editor.set_buffer(right_pane_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // IMPORTANT: Restore the original terminal buffer for the next frame                    self.editor.set_buffer(self.buffer.clone());                }                // --- Render Workflow Overlay (existing code) ---                else if let AppMode::Workflow(state) = &app.mode {                    let (width, height) = (self.config.width as f32, self.config.height as f32);                    let padding = 50.0;                    // Create a separate buffer for the UI overlay                    let mut ui_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    ui_buffer.set_size(&mut self.font_system, Some(width - padding * 2.0), Some(height - padding * 2.0));                    // --- Argument Editing UI ---                    if let Some(exec_state) = &state.execution_state {                        let mut text = format!("Workflow: {}\n\n", exec_state.workflow.name);                        for (i, arg) in exec_state.workflow.arguments.iter().enumerate() {                            let cursor = if i == exec_state.selected_arg_idx { ">" } else { " " };                            text.push_str(&format!("{}[{}]: {}\n", cursor, arg.description, exec_state.argument_values[i]));                        }                        ui_buffer.set_text(&mut self.font_system, &text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                                        // --- Workflow Browser UI ---                    } else {                        let mut text = format!("Search: {}\n\n", state.query);                        for (i, workflow) in state.filtered_workflows.iter().take(10).enumerate() { // Limit to 10 results                            let line = if i == state.selected_workflow_idx {                                format!("> {} - {}\n", workflow.name, workflow.description)                            } else {                                format!("  {} - {}\n", workflow.name, workflow.description)                            };                            text.push_str(&line);                        }                        ui_buffer.set_text(&mut self.font_system, &text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    }                    // Prepare and draw the UI buffer                    self.editor.set_buffer(ui_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    // We "fake" a background by drawing a huge block character behind the text                    self.editor.buffer_mut().set_text(&mut self.font_system, "â–ˆ", Attrs::new().color(Color::rgba(20, 20, 20, 200)).font_size(height), Shaping::Advanced);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // Now draw the actual UI text on top                    self.editor.shape_as_needed(&mut self.font_system, true); // Reshape with the UI text                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // IMPORTANT: Restore the original terminal buffer                    self.editor.set_buffer(self.buffer.clone());                } else if let AppMode::AgentManagement = &app.mode {                    // Draw overlay background                    let mut panel_text = "--- Agent Management ---\n\n".to_string();                    for pane in &app.panes {                        if let Some(agent_state) = &pane.agent_state {                            panel_text.push_str(&format!(                                "[{:?}] {} (Cancel)\n",                                agent_state.status, agent_state.task_summary                            ));                        }                    }                    let mut panel_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    panel_buffer.set_size(&mut self.font_system, Some(self.config.width as f32 * 0.6), Some(self.config.height as f32 * 0.6));                    panel_buffer.set_text(&mut self.font_system, &panel_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(panel_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                } else if let AppMode::DiffReview(state) = &app.mode {                    // Draw background overlay                    let (width, height) = (self.config.width as f32, self.config.height as f32);                    let padding = 40.0;                    let mut bg_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    bg_buffer.set_size(&mut self.font_system, Some(width), Some(height));                    bg_buffer.set_text(&mut self.font_system, "â–ˆ", Attrs::new().color(Color::rgba(20, 20, 20, 230)).font_size(height * 2.0), Shaping::Advanced);                    self.editor.set_buffer(bg_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // --- Draw Header and File Tabs ---                    let mut header_text = format!("{}\n\n", state.explanation);                    for (i, file) in state.files.iter().enumerate() {                        let tab = if i == state.current_file_idx {                            format!("> {} <", file.file_path)                        } else {                            file.file_path.clone()                        };                        header_text.push_str(&format!("{}   ", tab));                    }                    let mut header_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    header_buffer.set_size(&mut self.font_system, Some(width - padding * 2.0), Some(60.0));                    header_buffer.set_text(&mut self.font_system, &header_text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(header_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    // --- Draw Side-by-Side Diff for the current file ---                    let file = &state.files[state.current_file_idx];                    let mut left_text = String::new();                    let mut right_text = String::new();                    let mut left_spans = AttrsList::new(Attrs::new());                    let mut right_spans = AttrsList::new(Attrs::new());                    let mut left_offset = 0;                    let mut right_offset = 0;                    for (i, hunk) in file.hunks.iter().enumerate() {                        let prefix = if i == state.current_hunk_idx { "> " } else { "  " };                        match hunk.tag {                            ChangeTag::Delete => {                                left_text.push_str(&format!("{}{}", prefix, hunk.original_text));                                left_spans.add_span(left_offset..left_offset + prefix.len() + hunk.original_text.len(), Attrs::new().color(Color::rgb(255, 80, 80)));                                left_offset += prefix.len() + hunk.original_text.len();                                right_text.push('\n');                                right_offset += 1;                            }                            ChangeTag::Insert => {                                left_text.push('\n');                                left_offset += 1;                                right_text.push_str(&format!("{}{}", prefix, hunk.new_text));                                right_spans.add_span(right_offset..right_offset + prefix.len() + hunk.new_text.len(), Attrs::new().color(Color::rgb(80, 255, 80)));                                right_offset += prefix.len() + hunk.new_text.len();                            }                            ChangeTag::Equal => {                                left_text.push_str(&format!("{}{}", prefix, hunk.original_text));                                left_spans.add_span(left_offset..left_offset + prefix.len() + hunk.original_text.len(), Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)));                                left_offset += prefix.len() + hunk.original_text.len();                                right_text.push_str(&format!("{}{}", prefix, hunk.new_text));                                right_spans.add_span(right_offset..right_offset + prefix.len() + hunk.new_text.len(), Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)));                                right_offset += prefix.len() + hunk.new_text.len();                            }                        }                        left_text.push('\n');                        left_offset += 1;                        right_text.push('\n');                        right_offset += 1;                    }                    // --- Render the two panes ---                    let pane_width = (width - padding * 3.0) / 2.0;                    let pane_height = height - padding * 4.0 - 60.0;                    let mut left_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    left_buffer.set_size(&mut self.font_system, Some(pane_width), Some(pane_height));                    left_buffer.set_text(&mut self.font_system, &left_text, left_spans, Shaping::Advanced);                    self.editor.set_buffer(left_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    let mut right_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    right_buffer.set_size(&mut self.font_system, Some(pane_width), Some(pane_height));                    right_buffer.set_text(&mut self.font_system, &right_text, right_spans, Shaping::Advanced);                    self.editor.set_buffer(right_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    self.editor.set_buffer(self.buffer.clone());                    // --- Render instructions ---                    let instructions = "UP/DOWN: Select hunk   LEFT/RIGHT: Switch file   ENTER: Apply all   R: Refine   E: Edit   ESC: Cancel";                    let mut instr_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());                    instr_buffer.set_size(&mut self.font_system, Some(width - padding * 2.0), Some(30.0));                    instr_buffer.set_text(&mut self.font_system, instructions, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);                    self.editor.set_buffer(instr_buffer);                    self.editor.shape_as_needed(&mut self.font_system, true);                    self.editor.draw(&mut self.font_system, &mut self.swash_cache, &mut render_pass);                    self.editor.set_buffer(self.buffer.clone());                }            }        }                self.queue.submit(Some(encoder.finish()));        output.present();        Ok(())    }    fn render_input_bar(&mut self, app: &App, pos: (f32, f32), render_pass: &mut wgpu::RenderPass<'a>) {        let (x, y) = pos;        let mut display_text = String::new();        if let Some(vim_state) = &app.vim_state {            let mode_indicator = match vim_state.mode {                VimMode::Normal => "  NORMAL ",                VimMode::Insert => "  INSERT ",                VimMode::Visual => "  VISUAL ",            };            display_text.push_str(mode_indicator);        }        // Draw the user's actual input        self.editor.set_buffer(app.input_editor.buffer().clone());        self.editor.shape_as_needed(&mut self.font_system, true);        self.editor.draw(&mut self.font_system, &mut self.swash_cache, render_pass);        // Draw the autosuggestion as ghost text        if let Some(suggestion) = &app.autosuggestion {            // Calculate where the user's text ends            let mut last_run_x = 0.0;            let mut last_run_y = 0.0;            for run in self.editor.buffer().layout_runs() {                last_run_x = run.line_x + run.line_w;                last_run_y = run.line_y;            }            let ghost_color = Color::rgba(128, 128, 128, 128); // A dim grey            let mut ghost_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());            ghost_buffer.set_text(&mut self.font_system, suggestion, Attrs::new().color(ghost_color), Shaping::Advanced);            self.editor.set_buffer(ghost_buffer);            self.editor.shape_as_needed(&mut self.font_system, true);            self.editor.draw(&mut self.font_system, &mut self.swash_cache, render_pass);        }    }    fn render_cursor(&mut self, app: &App, pos: &GridCoords, render_pass: &mut wgpu::RenderPass<'a>) {        let (row, col) = (pos.y as f32, pos.x as f32);        let x = col * self.char_width;        let y = row * self.char_height;        let cursor_shape = if let Some(vim_state) = &app.vim_state {            match vim_state.mode {                VimMode::Insert => CursorShape::Bar,                _ => CursorShape::Block,            }        } else {            app.config.appearance.cursor.shape.clone()        };        let cursor_char = match cursor_shape {            CursorShape::Block => "â–ˆ",            CursorShape::Bar => "â–Ž",            CursorShape::Underline => " ", // Special case for underline        };        let cursor_color = hex_to_color(&app.theme.colors.cursor.cursor);        let mut cursor_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());        cursor_buffer.set_size(&mut self.font_system, Some(self.char_width), Some(self.char_height));        if cursor_shape == CursorShape::Underline {             let underline_y = y + self.char_height - (self.char_height / 4.0);             cursor_buffer.set_text(&mut self.font_system, "â–€", Attrs::new().color(cursor_color), Shaping::Advanced);             self.editor.set_buffer(cursor_buffer);             self.editor.shape_as_needed(&mut self.font_system, true);             self.editor.draw(&mut self.font_system, &mut self.swash_cache, render_pass);        } else {             cursor_buffer.set_text(&mut self.font_system, cursor_char, Attrs::new().color(cursor_color), Shaping::Advanced);             self.editor.set_buffer(cursor_buffer);             self.editor.shape_as_needed(&mut self.font_system, true);             self.editor.draw(&mut self.font_system, &mut self.swash_cache, render_pass);        }    }    fn render_history_search(&mut self, app: &App, state: &crate::app::state::HistorySearchState, render_pass: &mut wgpu::RenderPass<'a>) {        let (width, height) = (self.config.width as f32, self.config.height as f32);        let padding = 50.0;        // Draw background        let mut bg_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());        bg_buffer.set_size(&mut self.font_system, Some(width), Some(height));        bg_buffer.set_text(&mut self.font_system, "â–ˆ", Attrs::new().color(Color::rgba(20, 20, 20, 230)).font_size(height * 2.0), Shaping::Advanced);        self.editor.set_buffer(bg_buffer);        self.editor.shape_as_needed(&mut self.font_system, true);        self.editor.draw(&mut self.font_system, &mut self.swash_cache, render_pass);        // Draw UI text        let mut ui_buffer = Buffer::new(&mut self.font_system, self.editor.buffer().metrics());        ui_buffer.set_size(&mut self.font_system, Some(width - padding * 2.0), Some(height - padding * 2.0));        let mut text = format!("Search History: {}\n\n", state.query);        for (i, item) in state.filtered_list.iter().take(10).enumerate() {            let line = if i == state.selected_idx {                format!("> {}\n", item)            } else {                format!("  {}\n", item)            };            text.push_str(&line);        }        ui_buffer.set_text(&mut self.font_system, &text, Attrs::new().color(hex_to_color(&app.theme.colors.primary.foreground)), Shaping::Advanced);        self.editor.set_buffer(ui_buffer);        self.editor.shape_as_needed(&mut self.font_system, true);        self.editor.draw(&mut self.font_system, &mut self.swash_cache, render_pass);        self.editor.set_buffer(self.buffer.clone());    }}
